<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>squiral</title>
  <style>
    * { margin: 0; padding: 0; }
    html, body { width: 100%; height: 100%; overflow: hidden; background: black; }
    canvas { display: block; }
  </style>
</head>
<body>
  <canvas id="c"></canvas>
  <script>
    // squiral - port of xscreensaver hack by Jeff Epler (1999)
    // https://www.jwz.org/xscreensaver/

    const canvas = document.getElementById('c');
    const ctx = canvas.getContext('2d');

    // Configuration (matching original defaults)
    const config = {
      fill: 0.75,
      count: 0,          // 0 = auto (width/32)
      ncolors: 100,
      delay: 10,         // ms
      disorder: 0.005,
      handedness: 0.5,
      cycle: false,
      scale: 1,
      retinaScale: false   // if true, 3x scale on displays > 2560px
    };

    let width, height, scale;
    let grid;
    let worms;
    let cov;
    let inclear;
    let colors;
    let dirh, dirv;

    function mod(n, m) {
      return ((n % m) + m) % m;
    }

    function init() {
      scale = config.scale;
      if (config.retinaScale && (canvas.width > 2560 || canvas.height > 2560)) {
        scale *= 3;
      }

      width = Math.floor(canvas.width / scale);
      height = Math.floor(canvas.height / scale);

      dirh = [0, 1, 0, -1];
      dirv = [-1, 0, 1, 0];

      colors = [];
      for (let i = 0; i < config.ncolors; i++) {
        colors.push(`hsl(${(i * 360 / config.ncolors)}, 100%, 50%)`);
      }

      grid = new Uint8Array(width * height);

      let count = config.count || Math.floor(width / 32);
      count = Math.max(1, Math.min(1000, count));

      worms = [];
      for (let i = 0; i < count; i++) {
        worms.push({
          h: Math.floor(Math.random() * width),
          v: Math.floor(Math.random() * height),
          s: Math.floor(Math.random() * 4) + 4 * (Math.random() < config.handedness ? 1 : 0),
          c: Math.floor(Math.random() * config.ncolors),
          cc: config.cycle ? Math.floor(Math.random() * 3) + config.ncolors : 0
        });
      }

      cov = 0;
      inclear = height;
    }

    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      ctx.fillStyle = 'black';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      init();
    }

    function isClear(x, y) {
      return grid[mod(y, height) * width + mod(x, width)] === 0;
    }

    function fill(x, y) {
      const cx = mod(x, width);
      const cy = mod(y, height);
      grid[cy * width + cx] = 1;
      ctx.fillRect(cx * scale, cy * scale, scale, scale);
      cov++;
    }

    function canMove(x, y, dx, dy) {
      return isClear(x + dx, y + dy) && isClear(x + dx * 2, y + dy * 2);
    }

    function doMove(w, dir) {
      const dx = dirh[dir];
      const dy = dirv[dir];
      fill(w.h + dx, w.v + dy);
      fill(w.h + dx * 2, w.v + dy * 2);
      w.h = mod(w.h + dx * 2, width);
      w.v = mod(w.v + dy * 2, height);
      return dir;
    }

    function doWorm(w) {
      let type = Math.floor(w.s / 4);
      let dir = w.s % 4;

      w.c = (w.c + w.cc) % config.ncolors;
      ctx.fillStyle = colors[w.c];

      if (Math.random() < config.disorder) {
        type = Math.random() < config.handedness ? 1 : 0;
      }

      const ccw = (dir + 3) % 4;
      const cw = (dir + 1) % 4;

      let newDir = dir;
      let moved = false;

      const tryOrder = type === 0 ? [ccw, dir, cw] : [cw, dir, ccw];

      for (const d of tryOrder) {
        if (canMove(w.h, w.v, dirh[d], dirv[d])) {
          newDir = doMove(w, d);
          moved = true;
          break;
        }
      }

      if (!moved) {
        w.h = Math.floor(Math.random() * width);
        w.v = Math.floor(Math.random() * height);
        w.c = Math.floor(Math.random() * config.ncolors);
        type = Math.floor(Math.random() * 2);
        newDir = Math.floor(Math.random() * 4);
        if (config.cycle) w.cc = Math.floor(Math.random() * 3) + config.ncolors;
      }

      w.s = type * 4 + newDir;
    }

    function clearRow(y) {
      if (y >= 0 && y < height) {
        ctx.fillRect(0, y * scale, width * scale, scale);
        for (let x = 0; x < width; x++) grid[y * width + x] = 0;
      }
    }

    function frame() {
      if (inclear < height) {
        ctx.fillStyle = 'black';
        clearRow(inclear);
        clearRow(height - 1 - inclear);
        inclear++;
        clearRow(inclear);
        clearRow(height - 1 - inclear);
        inclear++;
        if (inclear > height / 2) inclear = height;
      } else if (cov > config.fill * width * height) {
        inclear = 0;
        cov = 0;
      }

      for (const w of worms) doWorm(w);

      setTimeout(frame, config.delay);
    }

    window.addEventListener('resize', resize);
    resize();
    frame();
  </script>
</body>
</html>
